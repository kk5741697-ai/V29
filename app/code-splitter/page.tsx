"use client"

import { TextToolLayout } from "@/components/text-tool-layout"
import { Split } from "lucide-react"

const codeSplitterExamples = [
  {
    name: "Multiple Functions",
    content: `function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price * item.quantity, 0);
}

function formatCurrency(amount) {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(amount);
}

function validateEmail(email) {
  const regex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return regex.test(email);
}

class UserManager {
  constructor() {
    this.users = [];
  }
  
  addUser(name, email) {
    if (!validateEmail(email)) {
      throw new Error('Invalid email');
    }
    this.users.push({ name, email });
  }
}`,
  },
  {
    name: "CSS with Multiple Sections",
    content: `/* Reset styles */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

/* Typography */
body {
  font-family: Arial, sans-serif;
  line-height: 1.6;
  color: #333;
}

h1, h2, h3 {
  margin-bottom: 1rem;
  font-weight: bold;
}

/* Layout */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 2rem;
}

/* Components */
.button {
  display: inline-block;
  padding: 12px 24px;
  background: #007bff;
  color: white;
  text-decoration: none;
  border-radius: 4px;
  transition: all 0.3s ease;
}

.card {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  padding: 2rem;
}`,
  },
]

const codeSplitterOptions = [
  {
    key: "splitBy",
    label: "Split By",
    type: "select" as const,
    defaultValue: "functions",
    selectOptions: [
      { value: "functions", label: "Functions/Methods" },
      { value: "classes", label: "Classes" },
      { value: "comments", label: "Comment Sections" },
      { value: "lines", label: "Line Count" },
      { value: "size", label: "File Size" },
    ],
  },
  {
    key: "linesPerFile",
    label: "Lines Per File",
    type: "slider" as const,
    defaultValue: 50,
    min: 10,
    max: 500,
    step: 10,
  },
  {
    key: "preserveImports",
    label: "Preserve Imports",
    type: "checkbox" as const,
    defaultValue: true,
  },
  {
    key: "addFileHeaders",
    label: "Add File Headers",
    type: "checkbox" as const,
    defaultValue: true,
  },
  {
    key: "createIndex",
    label: "Create Index File",
    type: "checkbox" as const,
    defaultValue: true,
  },
]

function processCodeSplitter(input: string, options: any = {}) {
  try {
    const codeType = detectCodeType(input)
    const splitResults = splitCode(input, codeType, options)
    
    let output = ""
    
    if (options.createIndex) {
      output += "// INDEX FILE\n"
      output += "// Generated by PixoraTools Code Splitter\n\n"
      
      splitResults.forEach((file, index) => {
        output += `// File ${index + 1}: ${file.name}\n`
        output += `// Lines: ${file.content.split('\n').length}\n`
        output += `// Size: ${file.content.length} chars\n\n`
      })
      
      output += "=".repeat(50) + "\n\n"
    }
    
    splitResults.forEach((file, index) => {
      output += `// FILE: ${file.name}\n`
      output += "=".repeat(30) + "\n\n"
      
      if (options.addFileHeaders) {
        output += `/**\n`
        output += ` * File: ${file.name}\n`
        output += ` * Generated: ${new Date().toISOString()}\n`
        output += ` * Lines: ${file.content.split('\n').length}\n`
        output += ` * Size: ${file.content.length} chars\n`
        output += ` */\n\n`
      }
      
      output += file.content
      
      if (index < splitResults.length - 1) {
        output += "\n\n" + "=".repeat(50) + "\n\n"
      }
    })

    const stats = {
      "Code Type": codeType.toUpperCase(),
      "Original Size": `${input.length} chars`,
      "Split Into": `${splitResults.length} files`,
      "Split Method": options.splitBy || "functions",
      "Average File Size": `${Math.round(input.length / splitResults.length)} chars`,
    }

    return { output, stats }
  } catch (error) {
    return {
      output: "",
      error: "Code splitting failed",
    }
  }
}

function detectCodeType(input: string): string {
  if (input.includes('function') || input.includes('const') || input.includes('let')) {
    return "javascript"
  }
  if (input.includes('{') && (input.includes('color:') || input.includes('margin:'))) {
    return "css"
  }
  if (input.includes('<') && input.includes('>')) {
    return "html"
  }
  return "javascript"
}

function splitCode(code: string, codeType: string, options: any): Array<{ name: string; content: string }> {
  const files: Array<{ name: string; content: string }> = []
  
  switch (options.splitBy) {
    case "functions":
      return splitByFunctions(code, codeType, options)
    case "classes":
      return splitByClasses(code, codeType, options)
    case "comments":
      return splitByComments(code, codeType, options)
    case "lines":
      return splitByLines(code, options)
    case "size":
      return splitBySize(code, options)
    default:
      return splitByFunctions(code, codeType, options)
  }
}

function splitByFunctions(code: string, codeType: string, options: any): Array<{ name: string; content: string }> {
  const files: Array<{ name: string; content: string }> = []
  const imports = extractImports(code)
  
  if (codeType === "javascript") {
    const functionPattern = /function\s+(\w+)[^{]*{[^{}]*(?:{[^{}]*}[^{}]*)*}/g
    const functions = []
    let match
    
    while ((match = functionPattern.exec(code)) !== null) {
      functions.push({
        name: match[1],
        content: match[0]
      })
    }
    
    functions.forEach((func, index) => {
      let content = ""
      if (options.preserveImports && imports) {
        content += imports + "\n\n"
      }
      content += func.content
      
      files.push({
        name: `${func.name}.js`,
        content
      })
    })
  } else if (codeType === "css") {
    const selectorPattern = /([^{}]+)\s*{[^{}]*}/g
    let match
    let fileIndex = 1
    
    while ((match = selectorPattern.exec(code)) !== null) {
      files.push({
        name: `styles-${fileIndex}.css`,
        content: match[0]
      })
      fileIndex++
    }
  }
  
  return files.length > 0 ? files : [{ name: "code.txt", content: code }]
}

function splitByClasses(code: string, codeType: string, options: any): Array<{ name: string; content: string }> {
  const files: Array<{ name: string; content: string }> = []
  const imports = extractImports(code)
  
  if (codeType === "javascript") {
    const classPattern = /class\s+(\w+)[^{]*{[^{}]*(?:{[^{}]*}[^{}]*)*}/g
    let match
    
    while ((match = classPattern.exec(code)) !== null) {
      let content = ""
      if (options.preserveImports && imports) {
        content += imports + "\n\n"
      }
      content += match[0]
      
      files.push({
        name: `${match[1]}.js`,
        content
      })
    }
  }
  
  return files.length > 0 ? files : [{ name: "code.txt", content: code }]
}

function splitByComments(code: string, codeType: string, options: any): Array<{ name: string; content: string }> {
  const files: Array<{ name: string; content: string }> = []
  const sections = code.split(/\/\*[\s\S]*?\*\/|\/\/.*$/gm)
  
  sections.forEach((section, index) => {
    if (section.trim()) {
      files.push({
        name: `section-${index + 1}.${getFileExtension(codeType)}`,
        content: section.trim()
      })
    }
  })
  
  return files.length > 0 ? files : [{ name: "code.txt", content: code }]
}

function splitByLines(code: string, options: any): Array<{ name: string; content: string }> {
  const files: Array<{ name: string; content: string }> = []
  const lines = code.split('\n')
  const linesPerFile = options.linesPerFile || 50
  
  for (let i = 0; i < lines.length; i += linesPerFile) {
    const chunk = lines.slice(i, i + linesPerFile)
    files.push({
      name: `part-${Math.floor(i / linesPerFile) + 1}.txt`,
      content: chunk.join('\n')
    })
  }
  
  return files
}

function splitBySize(code: string, options: any): Array<{ name: string; content: string }> {
  const files: Array<{ name: string; content: string }> = []
  const targetSize = Math.max(1000, Math.floor(code.length / 5)) // Split into ~5 files
  
  for (let i = 0; i < code.length; i += targetSize) {
    const chunk = code.substring(i, i + targetSize)
    files.push({
      name: `chunk-${Math.floor(i / targetSize) + 1}.txt`,
      content: chunk
    })
  }
  
  return files
}

function extractImports(code: string): string | null {
  const importLines = code.match(/^import\s+.*$/gm)
  return importLines ? importLines.join('\n') : null
}

function getFileExtension(codeType: string): string {
  switch (codeType) {
    case "javascript": return "js"
    case "css": return "css"
    case "html": return "html"
    case "json": return "json"
    default: return "txt"
  }
}

export default function CodeSplitterPage() {
  return (
    <TextToolLayout
      title="Code Splitter"
      description="Split large code files into smaller, manageable modules by functions, classes, or custom criteria."
      icon={Split}
      placeholder="Paste your code here to split..."
      outputPlaceholder="Split code files will appear here..."
      processFunction={processCodeSplitter}
      options={codeSplitterOptions}
      examples={codeSplitterExamples}
      fileExtensions={[".js", ".css", ".html", ".json"]}
      supportFileUpload={true}
      supportUrlInput={true}
    />
  )
}